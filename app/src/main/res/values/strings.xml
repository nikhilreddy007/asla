<resources>
    <string name="app_name">ASLA</string>
    <string name="tutorial">Tutorial</string>
    <string name="description">description</string>
    <string name="articles">Articles</string>
    <string name="faq">F.A.Q</string>
    <string name="quiz">Quiz</string>
    <string name="beginner">Beginner</string>
    <string name="intermediate">Intermediate</string>
    <string name="advanced">Advanced</string>
    <string name="general">General</string>g
    <string name="specific">Project specific</string>
    <string name="easy">Easy</string>
    <string name="medium">Medium</string>
    <string name="hard">Hard</string>
    <string name="contact_us">Contact us</string>
    <string name="help">Help</string>
    <string name="next">NEXT</string>
    <string name="skip">SKIP</string>
    <string name="got_it">GOT IT</string>

    <string name="_111_t">What is AUTOSAR?</string>
    <string name="_112_t">Why AUTOSAR?</string>
    <string name="_113_t">Who is AUTOSAR?</string>
    <string name="_114_t">Objectives of AUTOSAR</string>
    <string name="_115_t">Key focus of AUTOSAR</string>
    <string name="_116_t">AUTOSAR Roadmap</string>
    <string name="_117_t">Reach and Access AUTOSAR</string>
    <string name="_121_t">Layered Software Architecture</string>
    <string name="_122_t">Methodology</string>
    <string name="_123_t">Configuration Classes</string>
    <string name="_124_t">Conformance Classes</string>
    <string name="_211_t">Brief on Diagnostic modules</string>
    <string name="_212_t">DCM module</string>
    <string name="_213_t">DEM module</string>
    <string name="_214_t">Interaction between DCM, DEM and Application</string>
    <string name="_215_t">DET module</string>
    <string name="_216_t">FIM module</string>
    <string name="_221_t">Mode managers in AUTOSAR</string>
    <string name="_222_t">EcuM module</string>
    <string name="_223_t">WdgM module</string>
    <string name="_224_t">ComM module</string>
    <string name="_231_t">What are CDDs</string>
    <string name="_232_t">Interaction with CDDs</string>
    <string name="_233_t">What can be designed as CDDs?</string>
    <string name="_234_t">CDD as a Ser vice SW-C</string>
    <string name="_311_t">Introduction</string>
    <string name="_3120_t">Sub-Layers</string>
    <string name="_3121_t">Services Layer</string>
    <string name="_3122_t">ECU Abstraction Layer</string>
    <string name="_3123_t">Complex Device Drivers (CDD)</string>
    <string name="_3124_t">Micro Controller Abstraction Layer (MCAL)</string>
    <string name="_321_t">COM Stack basics</string>
    <string name="_322_t">COM Module</string>
    <string name="_323_t">PduR Module</string>
    <string name="_324_t">IPDU-M Module</string>
    <string name="_3250_t">FR/ CAN/ LIN Stack</string>
    <string name="_3251_t">Basics</string>
    <string name="_3252_t">Hardware Configuration</string>
    <string name="_411_t">Memory Stack basics</string>
    <string name="_412_t">NVRAM Manager Module</string>
    <string name="_413_t">NVRAM Manager as a Service SW-C</string>
    <string name="_414_t">MemIf module</string>
    <string name="_415_t">Flash/ Eeprom Stack</string>
    <string name="_421_t">Introduction</string>
    <string name="_4221_t">Fundamentals of AUTOSAR OS</string>
    <string name="_4222_t">Extensions to and restrictions on OSEK OS</string>
    <string name="_4223_t">OS Tasks</string>
    <string name="_4224_t">OS counters</string>
    <string name="_4225_t">OS Alarms</string>
    <string name="_4226_t">OS Events</string>
    <string name="_4227_t">OS Scheduler and Schedule tables</string>
    <string name="_4228_t">Schedule table Synchronization</string>
    <string name="_4229_t">ISRs and types</string>
    <string name="_42210_t">OS Resources</string>
    <string name="_42211_t">OS Protection</string>
    <string name="_42212_t">OS Hooks</string>
    <string name="_42213_t">Services to SchM</string>
    <string name="_423_t">OS Scalability classes</string>
    <string name="_431_t">Basics of Measurement and Calibration</string>
    <string name="_432_t">XCP module</string>
    <string name="_433_t">Calibration with FR/ CAN</string>
    <string name="_434_t">Interaction of XCP module</string>
    <string name="_511_t">Introduction</string>
    <string name="_512_t">RTE Concepts</string>
    <string name="_513_t">Calibration</string>

    <string name="_111_m1">
        AUTOSAR - AUTomotive Open System ARchitecture
        \n\nConsortium found in 2002 by auto manufacturers later joined by suppliers and silicon chip providers
        \n\nInitiative supported by auto industry to develop a de-facto open standard for automotive E/ E architectures
        \n\nFocuses to specify standard architecture for system software
        \n\nSoftware development based on function based approach
        \n\nAims to improve performance, safety and environmental electronic systems
   <string name="_111_m2">
        \nAUTOSAR consortium consists of three members identified based on their initiatives
\n\nThe members will be given appropriate rights and allocated to the various duties
\n\nMembers of AUTOSAR
\n  - Core partners
\n  - Premium members
\n  - Associate members
\n\nSupport members of AUTOSAR
\n  - Development members
\n  - Attendees
    </string>
    </string>
    <string name="_112_m2">
        To have a common requirements/ understanding between auto stake holders
        \n\nCreate a standard core for industry on basic functions where innovative functions are built on top of it
        \n\nHW and SW are widely independent. With parallel developments, reduces the development time and costs
        \n\nRe-use of software increases at OEMs and suppliers. Improve the quality and efficiency
        \n\nFaster development of auto software thru commercial design tools
        \n\nSoftware integration from multiple vendors at ease
    </string>
    <string name="_121_m5">
        Follows ‘Component’ style
\n\nInteraction between SW-Cs and to BSW thru RTE
\n\nFollows the methodology to interact between SW-Cs
\n\nSW-Cs shall be different types identified as on need basis
\n\nEach SW-C has a part of functionality of an application
    </string>
    <string name="_121_m6">
Acts as middle layer to abstract SW-Cs from BSW
\n\nMakes application layer independent of BSW layer
\n\nImplements communication mechanisms to interact within SW-Cs and between SW-C and BSW
\n\nInternal behavior of all SW-Cs in ECU will be configured and implemented here
    </string>
    <string name="_121_m7">
BSW has all the modules needed for application
\n\nAUTOSAR defines the specifications for the all the modules and their integration
\n\nHas modules to interact directly with hardware
\n\nHas OS for scheduling purposes
    </string>
    <string name="_121_m8">
The communication happens thru ports those implements interfaces as per communication mechanism
\n\nEach SW-C will have ports to interact
\n\nCommunication thru RTE
\n\nThe communication in BSW is abstracted to the SW-Cs
    </string>
    <string name="_123_m1">
        AUTOSAR supports 3 configuration classes
\n\nPre-Compile time
\n  - The software controlled by configuration at pre-compile time
\n  - Need to re-make the software upon changes
\n  - Support only parameters of Pre-Compile time
\n\nLink-time
\n  - The constant configuration data can be supplied as object code at link time (Warranty reasons, IP protection etc.)
\n  - Need to re-link the software upon changes
\n  - Support the parameters of Pre-Compile time and Link time
\n\nPost-build time
\n  - The constant configuration data can be supplied/ loaded at any time at known fixed entry point
\n  - Load new configuration data at any time
\n  - Support the parameters of all above
    </string>
    <string name="_124_m1">
        Has 3 Conformance Classes
\n  - ICC1
\n  - ICC2
\n  - ICC3
        \n\nThe classes are based on
\n  - AUTOSAR compliancy
\n  - Standardizationsacross different layers
\n  - Standardizationsacross sub-layers, clusters, stacks and modules etc.
    </string>

    <string name="_211_m1">Supports fault handling and reporting
\n\nThe possible errors/ failures AUTOSAR addresses are
\n  - Hardware errors
\n  - System errors
\n  - Software errors
\n\nAddressing the errors
\n  - Development stages
\n    - Reported to DET module
\n    - Feature can be switched OFF after development stage
\n    - Optional feature can be switched ON/ OFF
\n  - Production stages
\n    - Reported to DEM module
\n    - Feature shall be always ON to store and retrieve the permanent errors
\n    - Errors can be retrieved thru external tools
</string>
    <string name="_212_m1">Provides services for Diagnostics
\n\nInteracts over LIN/ CAN/ FR with external tools
\n\nSupports LIN/ CAN/ FR communication
\n\nInteracts with BSW directly, SWCs thru RTE to set/ get the data
\n\nInteracts with fault memory
\n\nHandles variety of diagnostic protocols</string>
    <string name="_212_m4">DCM functionalities
\n\nHandles diagnostic communication
\n\nInteracts with application
\n\nInteracts with ComM to handle communication states
\n\nHandles tester presence service
\n\nSecurity level handling
\n\nManaging diagnostics sessions
\n\nHandling various diagnostic protocols
\n\nService response handling
\n\nRealized as Ser vice SW-C</string>
    <string name="_213_m1">Provides services to
\n  - Process and access fault data
\n  - Snapshots fault data at occurrence
\n  - Accessto freeze frame data
\n\nProvide fault data to DCM
\n\nAccesses the NV memories to handle fault data
\n\nEnable/ Disable fault logging
\n\nFault reactions handled by FIM module
\n\nRealized as Service SW-C</string>
    <string name="_213_m2">More features of DEM
\n\nEvent combination (Optional feature)
\n\nPre-storage of Freeze frame data
\n\nSupports extended data records
\n\nDEM operation cycles
\n\nNV memory access
\n\nDe-bouncing algorithms for events
\n  - Count er/ Time/ Frequency based
\n    - DTC fault detection counter
\n\nRealized as Ser vice SW-C</string>
    <string name="_215_m1">BSW report the errors detected at development stages
\n\nThe report collects
\n  - Module occurred
\n  - Function occurred
\n  - Error classification
\n\nThe functionality is implementation specific
\n\nPossible use cases are
\n  - Count ing the errors
\n  - Log calls
\n\nRealized as Ser vice SW-C
</string>
    <string name="_216_m1">Control the fault reaction functionalities
\n\nFunctionalities check the inhibit conditions before executing
\n\nEvent status information acts as inhibit conditions
\n\nExample
\n  – A sensor can have inhibit conditions. Upon failure, the functionality checks the inhibit condition and stops executing
\n\nSupports summarized event
\n\nRealized as Service SW-C
</string>
    <string name="_221_m1">ECU has states between power-up to shutdown
\n\nStates on ECU, communication, network levels etc.
\n\nFor smooth operation, these states has to be transitioned
\n\nStates has to synchronize
\n\nIn AUTOSAR we have
\n  - ECU states: Managed by EcuM
\n  - Wdg states: Managed by WdgM
\n  - Communication states: Managed by ComM
\n\nApplication shall have their states and logic
</string>
    <string name="_222_m1">First module to be initialized in AUTOSAR software
\n\nInitializes the ECU state machine
\n\nInitializes all the modules
\n\nApplication need to request RUN/ SHUTDOWN states
\n\nHandles sleep and wake-up functionalities
\n\nPerforms wake-up validation
\n\nHandles initialization and shutdown procedure thru state machine
\n\nHandles various shutdown targets
</string>
    <string name="_222_m2">EcuM States
\n\nEcuM initialization starts the state machine
\n  - STARTUP states
\n    - STARTUP I
\n      - Start up state before OS started
\n      - Modules independent of OS are initialized
\n      - Fundamental needs for ECU (Mcu, Det etc.) are initialized
\n    - STARTUP II
\n      - Start up state after OS started
\n      - Modules dependant on OSare initialized
\n      - Modules with schedulable functions shall be initialized
</string>
    <string name="_222_m3">After STARTUP states, the state machine moves to
\n  - RUN states
\n    - RUN
\n      - Execution of application tasks
\n      - User has to request RUN state
\n      - If valid RUN request, ECU stays in RUN state
\n      - If no RUN request with in predefined t ime, moves to POSTRUN state
\n      - State shall be left if user releases the request
\n    - POSTRUN
\n      - If user has any post activities, need to request POSTRUN before releasing RUN
\n      - If RUN request, goes back to RUN state
\n      - State shall be left if user releases the request
\n      - If released, moves to SHUTDOWN state</string>
    <string name="_222_m4">After RUN states, the state machine moves to
\n  - SHUTDOWN states
\n    - PREP SHUTDOWN
\n      - Application is de-initialized
\n      - No network
\n      - If shutdown target is SLEEP, goes to GOSLEEP state else GOOFF I
\n    - GO SLEEP
\n      - Settings to made to go the sleep phase
\n      - If valid wakeup, clear and enable the interrupts and moves to WAKEUP state
\n      - Save NV data
\n      - Enable wake-up sources
\n      - Move Wdg state to SLEEP
\n      - For data safety, the RAM integrity algorithms shall be created
\n    - GOOFF I
\n      - De-initialize all modules dependant on OS
\n      - Set Wdg mode to shutdown
\n      - Save NV data
\n      - Set RESET as shutdown target, if any pending wakeup events found
\n      - Shut down OS
\n    - GOOFF II
\n      - If Shut down target is RESET, Mcu performs RESET else SHUTDOWN
</string>
    <string name="_222_m5">SLEEP state
\n  - SLEEP state achieved from GOSLEEP if there are no wake up events
\n  - No code is executed in this state as micro is halted
\n  - If any wakeup found on the way to SLEEP, moves to WAKEUP state
\n  - Wakeup sources should be enabled in SLEEP state
\n  - Upon a valid wakeup, WAKEUP state shall be achieved</string>
    <string name="_222_m6">WAKEUP states
\n  - WAKEUP I
\n    - Restore MCU and Wdg states to normal
\n    - Re-initialize the wakeup source drivers
\n    - Actual wake source should set an wakeup event
\n    - Disable wakeup sources
\n    - Unlock the scheduler
\n  - WAKEUP VALIDATION
\n    - Validate the pending wakeup events
\n    - Eliminate false wakeups
\n  - WAKEUP REACTION
\n    - Action to be taken on successful wakeup validation
\n    - Move to RUN, Shut down state etc..are possibilities
\n  - WAKEUP II
\n    - Initialize the diagnostics
\n    - Indicate the modes to RTE</string>
    <string name="_222_m7">EcuM as a Service SW-C
\n\nEcuM provides predefined ports to connect to application
\n  - Release/ Request RUN state
\n  - Release/ Request POST RUN state
\n  - Select / get shutdown target
\n  - Select / get application modes
</string>
    <string name="_222_m8">Configuration
\n\nEcuM SWC description can be arrived with
\n  - Port interfaces
\n    - S/R interfaces for getting modes
\n    - C/S interfaces for predefined ports
\n  - Modes
\n    - Mode ports and interfaces
\n  - Data types
\n    - Mode Declaration Gr oup with all ECU modes
\n    - All types of EcuM
\n  - Runnables
\n    - All EcuM services
\n    - EcuM services as server operations
</string>
    <string name="_223_m1">To supervise the reliability of software execution
\n\nProvides alive-supervision of application
\n\nTrigger the hardware Wdg
\n\nCan supervise multiple entities
\n\nTakes the decision on global supervision
\n\nEach SE has to provide live indications to WdgM
\n\nEcuM sync Wdg to ECU states
</string>
    <string name="_223_m2">Wdg Modes
\n\nSupports different modes
\n\nEach mode is defined by
\n  - Set of active SEs and their alive supervision parameters
\n  - Set of Wdgs to be tr iggered and their triggering parameters
\n\nSource of activation for cyclic activities of WdgM
\n\nConfigur able number of modes
\n\nDifferent modes used for phases of ECU
\n\nUpon errors, entry for DEM is available</string>
    <string name="_224_m1">Contr ols BSW related to communication
\n\nProcesses bus communication requests
\n\nAbstract the communication hardware and software
\n\nEnable/ Disable the communication signals/ messages
\n\nHighest state results upon multiple requests from same user
\n\nCover s FR, CAN and LIN buses
\n\nManages Network and state managers
\n\nManages bus errors
\n\nRealized as Ser vice SWC</string>
    <string name="_224_m2">Bus error management
\n\nNetwork start indication for specific bus channel
\n\nSwitch to FULL COM on this indication
</string>
    <string name="_231_m1">CDD – Complex Device Drivers
\n\nThe devices with need of complex processing time
\n\nStandard/ Non-standard from AUTOSAR
\n\nNo need to follow any standard within CDDs but AUTOSAR way to outside software
\n\nThe scaled AUTOSAR driver can also be a CDD
\n\nA highly compact IP design/ algorithm software can fit as CDD
\n\nNon-AUTOSAR communication drivers
</string>
    <string name="_232_m1">Interaction with in CDD is implementation specific
\n\nInteraction from CDD to application is thru RTE
\n\nNo abstraction layers between RTE, CDD and Hardware
\n\nPossible to interact with BSW modules
\n\nShall use OS for its schedulable entities
\n\nEcuM shall initialize
\n\nShall use OS for interrupts
\n\nShall use SPI for external communication
\n\nRealized as Ser vice SW-C
</string>
    <string name="_233_m1">Anything not available in AUTOSAR standards
\n\nAnything complex – Complex Sensors and Actuators
\n\nElectrical interfacing – Motor controls and actuators
\n\nComplex algorithm processing – DSP processors for Camer a/ Radar etc.
\n\nIP ASICs
\n\nProtocols - I2C, IP protocols etc.
\n\nCr ypto hardware services
\n\nDEShardware services</string>
    <string name="_234_m1">
        Realized as Ser vice SWC
\n\nSWC description can be made with below and imported in application
\n  - CDD data types
\n  - CDD APIs
\n  - CDD schedulable functions
\n  - CDD server operations
\n  - PDAVs for CDD APIs
\n  - Mode declaration groups etc.
    </string>

    <string name="_311_m1">Executes the functional part of application needs
\n\nBSW offers
\n  - Communication services
\n  - Diagnosticsservices
\n  - Calibration services
\n  - Memory services
\n  - Micro Controller services
\n  - OSser vices
\n  - Mode Management services
\n  - Complex Device Drivers
\n\nAccess to hardware
\n\nAbstract application from hardware for more portability
\n\nHardware independent BSW parts can be re-used completely
</string>
    <string name="_3120_m1">BSW has below main sub layers
\n  - Service layer
\n  - ECU Abstraction layer
\n  - Complex Device Drivers (CDD)
\n  - Micro Controller Abstraction Layer (MCAL)
</string>
    <string name="_3121_m1">Offer s basic services required for BSW and applications
\n\nServices include
\n  - System services
\n  - Memory services
\n  - Communication services</string>
    <string name="_3122_m1">Abstracts ECU hardware
\n\nAbstracts MCAL from Ser vice layer
\n\nInterfaces external devices
\n\nOffer s various abstraction services
\n  - Onboar d device abstraction
\n  - Memory hardware abstraction
\n  - Communication hardware abstraction
\n  - IO hardware abstraction
</string>
    <string name="_3123_m1">Enables to integrate special purpose functionality not specified in AUTOSAR
\n\nSpecific devices with high timing constraints
\n\nEnables a way for migration
\n\nCDDs hardware access is abstraction free
\n\nCDDs interact directly to RTE to less the latency</string>
    <string name="_3124_m1">Lowest layer access to hardware
\n\nAccess to micro controller peripherals, on-board modules
\n  - Micro controller drivers
\n  - Memory drivers
\n  - Communication drivers
\n  - IO drivers
</string>
    <string name="_321_m1">For Vehicle network communication, FR/ CAN/ LIN stacks available in AUTOSAR
\n\nA stack of modules i.e. comm driver, abstraction module, Tp operation, routing, unpacking/ packing of signals etc. makes a complete COM Stack
\n\nCOM managers (states, NM etc.), Calibration are also included to enhance
</string>
    <string name="_321_m2">A physical representation of a high numerical level data
\n\nSignal types
        \n\nHave a start position and initial value and updated to PDU directly
\n\nGroup Signal
\n  - A signal depending on other signals
\n  - Data has to be updated in shadow fir st
\n\nSignal group
\n  - A set of group signals packed in a complex signal
\n  -         May have 0…N group signals inside
\n  - Data has to be updated to PDU from Shadow
    </string>
    <string name="_321_m3">PDU (Protocol Data Unit)
\n  – A data unit packed with set of signals/ group signals
\n  - PDU can’t have both signals and group signals at a time
        \n\nPDU Group
\n  - A group of zero or more PDUs or PDU groups
\n  - A set of PDUs/ PDU Groups transmission/
     reception can be controlled by specific PDU Group start/ stop
\n  - Limited to 32 in an ECU
</string>
    <string name="_321_m4">All the PDUs info is available in EcuC
\n\nModules access EcuC for PDU properties
</string>
    <string name="_322_m1">Top BSW module communicating to RTE
\n\nProvides services to application thru RTE and rest of BSW COM Stack
\n\nFunctionalities of COM module includes
\n  - Signal and Message access
\n  - Both Signal and Message access and Gat eways by COM
\n  - Packing and un-packing of signals to/ from messages
\n  - Deadline monitoring
\n  - Filter based reception
\n  - EndianNess handling
\n  - Communication modes
\n  - Signal transfer modes
\n  - PDU Transmission modes
\n  - Signal indication modes
\n  - Immediate
\n  - Deferred
\n  - Communication transmission control (start/ stop of PDU groups)</string>
    <string name="_322_m3">Applied at reception
\n\nRemoves unwanted data and their processing
        \n\nSupports signed types also. No support for complex types
\n\nAlso used for Transmission Mode Selection (TMS)
</string>
    <string name="_322_m5">COM supports 2 modes for communication
\n  - Modes for Signals (Transfer properties)
\n  - TRIGGERED
\n  - PENDING
\n  - Modes for PDUs (Transmission modes)
\n  - PERIODIC
\n  - DIRECT/ N-TIMES
\n  - MIXED
\n  - NONE</string>
    <string name="_322_m6">
        Suppor ts for both interrupt and polling methods
\n\n2 modes
\n  - IMMEDIATE
\n  - DEFERRED
    </string>
    <string name="_322_m7">Communication can be enabled/ disabled for specific PDUs
\n\nPDUs can be logically grouped as groups and then controlled
\n\nTransmission control by state managers thru COM
\n\n2 levels of IPDU-Group depth allowed
</string>
    <string name="_323_m1">PduR Module placed between COM and FR/ CAN/ LIN Stack
\n\nProvides interfaces to communication related modules
\n\nFunctionalities of PduR module are
\n\nRouting functionality
\n  - Gateway functionality
\n  - Minimum Routing capability
\n  - Multi Cast operation
\n  - Zero Cost operation</string>
    <string name="_323_m3">Only predefined Pre-Compile and Link-time configurations possible
\n\nNo routing tables
\n\nOptional feature
</string>
    <string name="_323_m4">MultiCast Routing
\n\nMultiCast Gatew ay Routing</string>
    <string name="_323_m5">Eliminate PduR module actual functionality
\n\nPduR hand shakes between upper and lower layers with zero latency
\n\nPduR just maps the interfaces of source and destination modules
</string>
    <string name="_324_m1">Enables the multiplexing of PDUs
\n\nPossible only with static configuration
\n\nMultiplexed PDU will have Static and Dynamic parts
\n\nStatic part will have layout as configured
\n\nThe dynamic part may be multiplexed as configured and sent using same PDU Id</string>
    <string name="_3250_m1">Deals with FR/ CAN/ LIN services
\n\nA stack includes
\n  - &lt;X&gt;Driver
\n  - &lt;X&gt;Internal Driver
\n  - &lt;X&gt;External Driver interfaced with SPI
\n  - &lt;X&gt;If module
\n  - LIN Tp is integrated with LIN If
\n  - &lt;X&gt;Tp module
\n  - No separate LIN Tp
\n  - &lt;X&gt;Sm module
\n  - &lt;X&gt;Nm module
\n\nOver view of these modules are in next slides</string>
    <string name="_3251_m3">Tp Operation
\n\nSegments large data into PDU size
\n\nRe-assemble segmented PDUs into large chunk
\n\nMaintains a protocol with flow control
\n\nTransmit cancellation
\n\nUses Timer resources

\n\nExample:
\nPduR trying to send 50bytes
</string>
    <string name="_3251_m4">State Management
\n\nHandles communication states
\n\nAligns the transceiver modes based on application needs
\n\nControl the PDU groups
\n\nAnswers the bus errors (bus-off) by moving into safe states
\n\nBased on requested communication mode, the transmission/ reception can be stopped and started
\n\nHandles timeout for Deadline monitoring

\n\n\n\nAbstraction modules
\n\nAbstract CAN hardware
\n\nControl the CAN driver and transceiver
\n\nControl the external CAN hardware interface thru SPI
\n\nHandles transmit confirmations
\n\nHandles reception, bus-off and wake-up notifications
\n\nConfigure software mailboxes with BASIC/ FULL fashion
\n\nMultiple CAN driver support
</string>
    <string name="_3251_m5">Network Management
\n\nCo-ordinate between network states
\n\nRealized thru voting mechanism. Consolidation of ECUs votes on periodic basis results in taking the decision
\n\nAble to detect all present nodes and nodes which are ready to sleep
\n\nSupports bus-sleep and wake-up mechanisms
\n\nPartial networking not supported
\n\nHas the below modes
\n  - Network mode
\n  - Prepare Bus-Sleep mode
\n  - Bus-Sleep mode</string>
    <string name="_3252_m1">The respective HW (FR/ CAN/ LIN) has to be configured with
\n  - Mailboxes
\n  - HW filters
\n  - ISR/ Polling based communication
\n  - Transceiver configuration
        \n\n\nMailboxes configuration
\n\nCAN controller has predefined HW mailboxes
\n\nEach mailbox associated with HW filter to pass through
\n\n&lt;X&gt;If module can have SW mailboxes for the respective HW mailboxes
\n\nHW mailboxes can be assigned in BASIC/ FULL CAN fashion
</string>
    <string name="_3252_m2">HW filters
\n\n        Each HW mailbox associated with HW filter
\n\nHW filter helps to send/ receive only filtered message with matching ID in FULL CAN
\n\nIn BASIC CAN, a filter can allow messages with the range of IDs passed thru the filter
       \n\n\n ISR/Polling based message access
\n\nWith ISRs, the reception of data in HW mailbox is tr iggered with ISR
\n\nIf indications/ notifications are configured, they will be tr iggered
\n\nBus-Off and Wake-up processing can by done by ISR tr iggering
\n\nWith Polling, CanIf has to poll for reception
\n\nThe schedulable functions of CAN has to take care of the data and notifications
</string>
    <string name="_3252_m3">Transceiver configuration
\n\nConver ts bus logical signals to physical signals
\n\nAble to detect bus errors
\n\nSleep, Wake-up etc. modes shall be configured
\n\nIO pins used for transceiver shall be configurable
\n\nAlways powered-on to detect the wake-ups
</string>

    <string name="_411_m1">The Stack of modules for memory access
\n\nFlash and Eeprom are available in AUTOSAR
\n\nStack includes memory manager, abstraction and memories
\n\nExternal memories can be interfaced with SPI
\n\nProvides synchronous/ asynchronous services to memory access
</string>
    <string name="_411_m2">Types of memories
\n\nThe Memory Stack deals with
\n  - ROM
\n  - RAM
\n  - NV Memory (Flash/ Eeprom)
\n\nROM memory exists in FLASH
\n\nRAM memory as usual in RAM
\n\nNV memory (Flash and Eeprom) divided into pages, blocks etc.
\n\nFew differences are below
</string>
    <string name="_412_m1">Manages NV memories
\n\nSynchronous and asynchronous services for handling NV data
\n\nServices to read/ write all blocks  at once
\n\nProtection facility for the NV layout
\n\nUses abstraction to select the specific memory
\n\nUses CRC module
\n\nManages the memory as NV blocks</string>
    <string name="_412_m2">Memory blocks
\n\nMemory Stack deals with blocks
\n  - ROM block
\n  - RAM block
\n  - NV block
\n  - Administrative block
\n\nROM block resides in Flash
\n\nNV block resides in Flash/ Eeprom
\n\nRAM and NV blocks shall have CRC (optional)
\n\nAdministrative block reside in RAM having block index for dataset NV blocks

\n\n\nTypes of memory blocks
\n\n3 types of blocks
\n  - Native block
\n  - Redundant block
\n  - Native block + Its redundant copy
\n  - Dataset block
\n  - N number of Native blocks arranged as arrays and accessed with index</string>
    <string name="_412_m3">Block management types
\n\nA single NVM block can associate with
\n  - Its ROM block
\n  - Its RAM block
\n  - Its Administrative block
        \n\nJob Processing
\n\nSupports priority based job processing
\n\nMaintains 2 queues
\n  - Immediate Write jobs
\n  - Rest of immediate read/ erase jobs
\n\nImmediate write job has high priority</string>
    <string name="_412_m4">Services for NV data access
\n\nThree API configuration classes
\n  - API configuration class 1
\n  - Get error and Set block status
\n  - ReadAll, WriteAll, CancelWr iteAll
\n  - API configuration class 2
\n  - Class 1 +
\n  - Dataset block support
\n  - Read block, Write block and Restoring block defaults
\n  - API configuration class 3
\n  - Class 2 +
\n  - Block protection
\n  - Erase and Invalidate the block</string>
    <string name="_412_m5">Read block strategy
\n\nROM defaults are read at the very first journey
\n\nIf NV block data available,
\n  - RAM mirror updated from native NV block
\n  - RAM mirror updated from redundant block upon its native block read failure
\n  - RAM mirror updated with ROM defaults
\n\nIf invoked with a valid ptr, returns the ptr with NV block
\n\nIf invoked with NULL, the NV data copied to its RAM block
\n\nNotifications configurable for asynchronous read calls

\n\n\nWrite block strategy
\n\nIf any changes in RAM block data, updated to its NV block
\n\nNo change in RAM block contents results no writing
\n\nNotifications configurable for asynchronous write calls</string>
    <string name="_412_m6">ReadAll blocks strategy
\n\nReadAll blocks synchronously/ asynchronously
\n\nHappens mostly at ECU start-up
\n\nBlocks need to be configured for this feature
\n\nThe data is loaded to their respective RAM mirrors
\n\nIf corrupted/ errors
\n  - Redundant block data are loaded
\n  - ROM defaults are loaded
\n\nNotification configurable for asynchronous calls

\n\n\nWriteAll blocks strategy
\n\nWriteAll blocks synchronously/ asynchronously
\n\nHappens mostly at ECU shutdown
\n\nBlocks need to be configured for this feature
\n\nRAM mirrors are written back upon changes
\n\nSupports aborting on-going WriteAll operation</string>
    <string name="_412_m7">Configuration of NVRAM blocks
\n\nConfigure NVRAM blocks as required
\n\nEach NVRAM block has properties of
\n  - CRCused
\n  - Block management type
\n  - Block length
\n  - RAM and ROM blocks reference
\n  - Select for ReadAll()
\n  - Notification
\n  - Target block reference
\n\nEssential blocks to be configured
\n  - Multi block
\n  - Native block read/ written by ReadAll and WriteAll
\n  - No RAM/ ROM reference
\n  - No target reference
\n  - Config ID block
\n  - Redundant block holding ConfigID for NV memory layout
\n  - Integrity check on flashed ConfigID vs configured CompiledConfigID while ReadAll()</string>
    <string name="_412_m8">DatasetSelectionBits
\n\nLSB bits used to index the datasets
\n\nLSB bits used are from NvMBlockBaseNumber
\n\nTargetBlockNumber = (NvMBlockBaseNumber &lt;&lt; DatasetSelectionBits)
</string>
    <string name="_413_m1">Application interacts with NVRAM thru RTE
\n\nInteraction thru AUTOSAR interfaces thru RTE
\n\nNotifications issued to SW-Cs for Async requests</string>
    <string name="_413_m2">Configuration
\n\nSW-C description has to be arrived with
\n  - Data types
\n  - NVRAM types, return values etc.
\n  - Port s
\n  - C/ Sservice ports
\n  - Port interface
\n  - C/ Sinterface
\n  - NVRAM servicesas operations
\n  - Internal Behavior
\n  - RTE events
\n  - Events for tr iggering
\n  - Runnable entities
\n  - NVRAM servicesas Runnable entities tr iggered concurrently</string>
    <string name="_414_m1">Abstracts from lower memory layers
\n\nDiverts NVRAM Manager requests to target blocks
\n\nNo specific initialization
\n\nServices to support/ abstract NVRAM services</string>
    <string name="_415_m1">Abstracts physical memories to above layers
\n\nPhysical addressing happens
\n\nBlock number calculated as per NVRAM configuration
\n\nPhysical Flash/ Eeprom layout configuration. Enables interrupts
\n\nManages read/ write cycles
\n\nServices to read/ write/ compare/ status blocks</string>
    <string name="_415_m2">Notifications configured for Async requests
\n\nConfigured for multi/ single blocks
\n\nJob error/ end notifications possible
</string>
    <string name="_415_m3">External memory interfacing
        \n\nPossibility of interfacing external Eeprom
\n\nExt memories are interfaced thru SPI
\n\nExt Eeprom driver available at Abstraction layer
\n\nNeeds additional modules and configuration (DMA, GPIO pins for SPI etc.)
</string>
    <string name="_421_m1">The schedulable entities are scheduled by OS
\n\nOS supports time, event based scheduling
\n\nMostly OS is statically configured
\n\nProvides protection schemes for safety and hw resources
\n\nSupports Single/ Multi core OS
\n\nHandles deadlines
\n\nVector table to register interrupts
\n\nSuppor ts multiple OS-Applications
\n\nHook functions for tracing
\n\nProvides services to work with basic OS objects
\n\nSuppor ts Confor mance classes for different applications
\n\nProvides standardized interfaces
\n\nProvides different scalability classes and error checking</string>
    <string name="_4221_m1">Fundamentals of AUTOSAR OS
\n\nConfigur ed and scaled statically
\n\nProvides different scheduling methods
\n\nProtection features
\n\nOSEK OS is the basis for AUTOSAR OS
\n\nHandling interrupts and priorities
\n\nSuppor ts schedulable tables for synchronization
\n\nOS-Applications
\n\nScalability classes
\n\nHook functions for tracing
\n\nError checking</string>
    <string name="_4222_m1">Extensions to and restrictions on OSEK OS
\n\nAUTOSAR OS doesn’t support internal communication
\n\nPortability improvement with defined behavior
\n\nExtended level of error checking
\n\nStar tOS() shall not return
\n\nDefined process of OS shutdown
\n  - Disabling all the interrupts
\n  - Entering into endless loop
\n\nAvailability of interrupts at OS start and OS shutdown
\n\nImproved the actions on Alarm expiry
\n  - Incrementing the software counter
\n\nDedicated service to increment the counters
</string>
    <string name="_4223_m1">OS Tasks
\n\nApplication synchronizes by executing tasks
\n\nScheduled entities by OS
\n\nExecuted concurrently or asynchronously
\n\nTasks has priority
\n\nTasks triggered by alarms or scheduled expiry points
\n\nMultiple activation of tasks possible
\n\nOS Services available for scheduling
\n\n2 Types
\n  - Basic Task
\n  - Have finite time of execution
\n  - No waiting allowed
\n  - Can have ‘n’ number of basic tasks for application synchronization
\n  - Pre-emption based on priority</string>
    <string name="_4223_m2">Extended tasks
\n\nTasks may/ may not return
\n\nCan wait forever
\n\nOn waiting state, the processor switches to next priority task
\n\nConsumes more resources
</string>
    <string name="_4224_m1">OS Counters
\n\nRepresented as value incremented at constant speed
\n\nMeasured as ‘ticks’
\n\nLinks to Alarms and configures action on its expiry
\n\nCan be hardware or software timer
\n\nSer vice to operate on counters
\n\nAt least one counter is needed
\n\nConfigured statically
\n\nCounter actions
\n  - Triggering interrupts
\n  - Triggering alarms etc.</string>
    <string name="_4225_m1">OS Alarms
\n\nFor time based tr iggering
\n\nUses counters
\n\nCan be AutoStar t
\n\n2 types
\n  - Cyclic
\n  - Non-Cyclic
\n\nAlarm actions
\n  - Activate the tasks
\n  - Set events
\n  - Increment the counter
\n  - Alarm call-back
\n\nMultiple alarms can use same counter</string>
    <string name="_4226_m1">OS Events
\n\nConnecting synchronization points
\n\nAvailable for extended tasks only
\n\nApplication events possible to sync its logic
\n\nServices offered to work with events directly
\n\nEvents may occur on
\n  - Expiry of t imer/ alarm
\n  - Successful of transmission/ reception of signal/ message
\n\nRules and restrictions
\n  - All tasks can set the events
\n  - The owner of task only clears/ wait for event. Exception for extended tasks
\n  - ISR and Basic tasks can’t wait for event
\n\nEvents are key to release from waiting state</string>
    <string name="_4227_m1">OS Scheduler
\n\nSchedules the tasks as per scheduling schemes
\n\nThe tasks has to be activated to schedule them
\n\nState transitions
\n  - On activation, task moved to Ready state
\n  - Priority and scheme resolved, task moved to Running state
\n  - Waiting for event inside, task moved to Waiting state and schedule next priority task
\n  - Higher priority task arrived, move existing task to Ready and new task to Running
\n  - Event occurred in Waiting state, move the running and waiting tasks to Ready state
\n  - Task terminated, task moved to Suspended state
\n\nScheduler tr iggered either
\n  - By alarm expiry
\n  - Schedule table expiry points
\n\nPossible to lock Scheduler
\n\nServices to work with tasks and scheduler</string>
    <string name="_4227_m2">Schedule table
\n\nTable with predefined actions on expiry points
\n\nStatically defined tables. Run-time switching between tables allowed
\n\nCan be cyclic or non-cyclic
\n\nUses counter to check expiry points
\n\nExpiry points could be either absolute or relative to the counter
\n\nPossible actions on expiry
\n  - Set an event
\n  - Activate a task directly</string>
    <string name="_4228_m1">Schedule table synchronization
\n\nSupports 2 methods
\n  - Implicit
\n  - Done with counter attached to it (FlexRay/ TTP)
\n  - Explicit
\n  - Done with synchronization counter (additional functionality by OS )
\n  - Done by the user explicitly

\n\n\nScheduling schemes
\n\nProvides variety of scheduling schemes for OS applications
\n\nThe main schemes are
\n  - Full pre-emptive
\n  - Non pre-emptive
\n  - Mixed pre-emptive
\n  - Etc.</string>
    <string name="_4229_m1">ISRs and Types
\n\nTriggered directly from hardware
\n\nHighest priority than OS tasks
\n\nNo waiting inside ISR
\n\n2 types
\n  - ISR Category1
\n  - Should not use OS services
\n  - Least overhead on scheduling
\n  - Finitet ime execution
\n  - ISR Category2
\n  - Can use OS services
\n  - Can maintain its own stack
\n  - The pre-empted task shall resume once ISR completes</string>
    <string name="_42210_m1">OS Resources
\n\nShare resources with coordination
\n\nShared between tasks and ISRs also
\n\nWaiting not allowed after acquiring resource
\n\nNo nesting of lock and unlock the resource with in the task/ ISR
\n\nResources has to be managed to get r id of
\n  - Deadlocks
\n  - Priority inversion
\n\nSolution for issues with Resources
\n  - Priority Ceiling Protocol
\n  - Scheduler
\n\nTypes of Resources</string>
    <string name="_42211_m1">OS Protection
\n\nProtection for OS objects
\n\nOS objects assigned to OS applications
\n\nProtection types
\n  - Memory Protection
\n  - Code, Data and St ack of an OS application
\n  - No sharing of memory objects across OSapplicat ions
\n  - Timing Protection
\n  - Occurs at deadline missing
\n  - Execution budget of Tasks and Cat 2 ISRs
\n  - Lock budget for resources of tasks and ISRs
\n  - Inter-arrival t ime of tasks</string>
    <string name="_42211_m2">\n\nService Protection
\n  - OS Service calls corrupting OS itself
\n  - Invalid handles
\n  - Wrong contexts
\n  - Wrong resource locking/ unlocking
\n  - Unwanted calls/ access across OS applications
\n\nHardware protection
\n  - Highly useful in hardware mode (privileged/ non-privileged etc.)
\n  - Protection for restricted hardware resources(peripherals, registers etc.) belonging to specific mode etc.
\n  - Useful in non-trusted OS-Applications</string>
    <string name="_42212_m1">OS Hook functions
\n\nAllows user defined actions at specific OS occasions
\n\nHelps to trace
\n\nInvoked by OS itself
\n\nHigher priority than tasks and ISRs
\n\nFollows standardized interface
\n\nHook functions available at
\n  - System start-up
\n  - System shutdown
\n  - OSErrors
\n  - OSProtection violations</string>
    <string name="_42213_m1">Service to SchM
\n\nSchM is BSW Schedule Manager
\n\nHandles BSW schedulable functions
\n\nProvides services to handle critical regions of BSW modules
\n\nSupports to all BSW module instances
\n\nTask scheduling done by OS
</string>
    <string name="_423_m1">Customize the OS
</string>
    <string name="_431_m1">Access the ECU memory after deployment
\n\nMeasurement reads the data
\n\nCalibration reads and edits the data
\n\nFine tune the data by calibrating to study application behavior
\n\nChange the calibration data from external device
\n\nJust by changing the calibrated data, the same software can be re-used to multiple vehicle variants/ platforms
\n\nXCP facilitates all the above</string>
    <string name="_432_m1">Protocol between a master and slave device
\n\nBased on ASAM standards
\n\nProvides
\n  - Access the data synchronously/ asynchronously
\n  - Data stimulation (for rapid prototyping)
\n  - On-line memory calibration
\n  - Flash programming
\n  - FR/ CAN buses supported
\n  - More optional features
\n  - Available from AUTOSAR R4.x onwards</string>
    <string name="_433_m1">FR and CAN buses are supported
\n\nXCP messages sent/ received as per ASAM format
\n\nCoding and De-coding of message done be respective Master and Salve
\n\nXCP thru CAN
\n  - XCP PDUs communication thru AUTOSAR CAN St ack
\n  - 2 dedicated CAN IDs (Each one for Tx, Rx) need to be configured for XCP
\n  - Messages decoded/ encoded by CCP module
\n\nXCP thru FR
\n  - XCP PDUs communication thru AUTOSAR FR St ack
\n  - XCP messages on FR shall be event driven
\n  - Multiple PDUs can be packed and sent in a single FR PDU</string>

    <string name="_511_m1">Abstracts BSW from application
\n\nAllows parallel SW development
\n\nCompletely auto-generated for specific ECU
\n\nVFB realized thru implementation of RTE
\n\nProvides services to SW-Cs and to BSW to access the data/ services
\n\nProvides data integrity and consistency mechanisms
\n\nRunnables are scheduled by OS
\n\nRTE events to synchronize the application needs
\n\nCommunication with in Runnables
\n\nImplements VFB TRACE
</string>
    <string name="_512_m1">Software Components
\n\nLocated above RTE
\n\nFollows component style methodology
\n\nRTE implements the interaction for SW-Cs
\n\nSW-C is location independent, instantiated and highly re-usable
\n\nSW-C description linked with RTE features

\n\n\nCompositions
\n\nGgroup of SW-Cs interconnected
\n\nDelegation connectors used to connect to outside SW-Cs
\n\nIs of SW-C type and can use all features of an atomic SW-C
\n\nCommunication possible with in composition
        \n\n\nCommunication paradigms
\n\nProvides communication schemes for SWCs
\n\nThe schemes communicate thru ports
\n\nFor inter-communication, RTE uses COM
\n\nFor intra-communication, RTE may use COM or implements on its own
\n\nSchemes based on communication via data/ services
\n\n2 Schemes for Inter-SWC and to BSW
\n  - Sender -Receiver (S/ R)
\n  - Client -Ser ver (C/ S)
\n\nScheme for Intra-SWC
\n  - Inter-Runnable communication
        \n\n\nSender-Receiver communication
\n\nTransport of data from Sender to Receiver
\n\nSingle S/ R interface shall have many data elements. But data element transport will happen as per the contract with respective ports
\n\nOne way communication. No acknowledgement
\n\nFiltering allowed on RTE level
\n\nWith LIFO fashion, both 1:N, N:1 are allowed
\n\nWith FIFO and queued fashion, both 1:N, N:1 are allowed
\n\nFor modes communication, its only 1:N is allowed
</string>
    <string name="_512_m2">Client-Server communication
        \nClient requests for Ser ver’s services
\n\nSW-C can be a Client and Ser ver
\n\nA Client shall have multiple Ser vers
\n\nClient types
\n  - Synchr onous clients
\n  - Asynchronous clients
\n\nOnly N:1 is allowed
\n\nC/S interface shall have ‘n’ number of operations. Server offers the service based as per the contract with respective ports
\n\nServer shall address serialization
\n\nTwo way communication
\n\nSupports both LIFO and FIFO fashions
\n\nUsed for accessing Service SW-Cs
</string>
    <string name="_512_m3">Inter-Runnable communication
\n\nThe local data of Runnable is abstracted with others
\n\nThe data can’t be shared directly
\n\nRTE provides services to transport the data between Runnables
\n\nAllowed for multiple instantiation also
\n\nSer vices to read and write the inter-runnable variables
\n\nThis communication doesn’t need
\n  – Ports and Interfaces
</string>
    <string name="_512_m4">Runnable entities
\n\nThe atomic SW-C is divided into small executables ‘Runnables’
\n\nRunnables use RTE and OS services
\n\nActivated by RTE thru RTE events
\n\nServer runnables doesn’t need activation if invoked concurrently. No OS Task mapping in this case
\n\nRunnables are mapped to OS Tasks</string>
    <string name="_512_m5">Runnable entity types
\n\nCategorized based on its severity
\n\n3 runnable types
</string>
    <string name="_512_m6">Data accessing methods for Runnable entities
\n\nRunnables access the data thru accessing methods
\n\nAccessing methods related to communication schemes
\n\nQueuing always be on receiver side
\n\nCommunication schemes
\n  – Sender / Receiver
\n  – Implicit access
\n  – The updated data received automatically when Runnable starts
\n  – The data updated is shared to other Runnables at the earliest of its termination
\n  – Only non-blocking access
\n  – Explicit access
\n  – Runnable sends/ receives the data elements explicitly
\n  – Based on Runnable types, the access could be blocking or non-blocking
\n  – Client / Ser ver
\n  – Synchronous access
\n  – Blocking until Ser ver finishes the operation
\n  – Asynchronous access
\n  – Non-blocking Client . Ser ver notifies the completenessof operation
</string>
    <string name="_512_m8">RTE Events
\n\nTo wait and resolve the dependencies
\n\nTypes of Events
\n  - Timing event (T)
\n  - DataReceivedEvent (DR)
\n  - DatareceiveError Event (DRE)
\n  - DataSendCompleteEvent (DSC)
\n  - OperationInvokedEvent (OI)
\n  - AsynchronousSer ver CallRetur nsEvent (ASCR)
\n  - ModeSw ithEvent (MS)
\n\n\nRunnable entities and RTE Events
\n\nRunnable entities are activated by RTE events
\n\nAll events are associated with Runnables
\n\nRelease the runnables from WaitPoints
</string>
    <string name="_512_m9">Mapping Data Elements to Signals
\n\nIntra-communication of data handled by RTE
\n\nInter-communication of data is handled by COM
\n\nData elements are mapped to COM signals
\n\nSimple data elements mapped to a normal COM signal
\n\nComplex data elements mapped to Signal groups
</string>
    <string name="_512_m10">AUTOSAR Services
\n\nDeals with AUTOSAR Ser vice modules
\n\nApplication interacts with BSW services
\n\nInteraction thru Ser vice ports
\n\nStandar dized AUTOSAR interfaces shall be used
\n\nC/ Sinterface is used
\n\nService BSW modules are
\n  - NvM
\n  - WdgM
\n  - ComM
\n  - EcuM
\n  - DET and DEM
\n  - DCM and FIM
\n  - GPT
\n\nSW-C description for the above modules shall be made and available to SW-Cs
\n\nService APIs invoked as simple Cfunctions leaving no overhead
        \n\n\nService port mapping
\n\nService ports on both SW-C and Ser vice module
\n\nShall follow C/ Scommunication
\n\nThe mapping may be done with a simple Cbasics
</string>
    <string name="_512_m11">Port Defined Argument Values
\n\nHow to have unique Ids thru out ECU software?
\n\nHow does SW-Cs know about DEM Fault/ NvM Block Ids?
\n\nHard code the Ids thru Client ports. Ids appended as arguments
</string>
    <string name="_512_m12">Exclusive areas
\n\nGuarantee data consistency
\n\nGuard the data against concurrent accesses
\n\nMechanisms used are
\n  - Sequential scheduling strategy
\n  - Interrupt blocking strategy
\n  - Usage of OSr esources
\n  - Task blocking strategy
\n  - Cooper ative Runnable placement strategy
\n  - Etc.
\n\nServices to access the cr itical sections of data
\n  - Rte_Enter
\n  - Rte_Exit
        \n\n\nModes
\n\nStart/ Stop runnables on entering/ exiting the modes
\n\nSW-C user of these modes are called mode user
\n\nChanges of modes notified to the mode user by the respective mode manager
\n\nMode user gets mode switch notifications upon changes
</string>
    <string name="_512_m13">Mode ports and interface
\n\nMode managers in AUTOSAR
\n  - ComM
\n  - WdgM
\n  - EcuM
\n\nNeed Ser vice mode ports to avail this feature
\n\nAssociated with ModeSw itchEvents
\n\nMode switch shall be synchronous/ asynchronous
\n\nMode Sw itch Interface supports only 1:N communication
\n\n\nVFB Trace
\n\nTrace the data with user defined functions
\n\nTemplates auto generated but functions has to be defined by user
\n\nRTE services are configurable for hook functions
\n\nSwitch ON/ OFF facility for tracing
\n\nTrace is also possible for Runnables
\n\nCOM signals can also be monitored on VFB
\n\nOS is also traceable
\n\n\nRTE Generation phases
\n\nRTE is completely auto generated
\n\nTwo phases available for different project life cycle
\n\nPhases
\n  - Contract Phase
\n  - Generation of SW-C header templates only
\n  - General RTE types file
\n  - Only SW-C description is needed
</string>
    <string name="_512_m14">Generation Phase
\n\nComplete ECU description files needed
\n\nComplete generation of RTE
\n\nRelationships with BSW modules are also generated
</string>
    <string name="_512_m15">RTE Source and Header files
\n\nRTE generation produces output files
\n  - Rte_&lt;SW-C&gt;.h
\n  - RTE API mapping
\n  - Declaration of Runnables, RTE APIs
\n  - Initial values
\n  - Rte-Type.h
\n  - Types of RTE needs and user defines types
\n  - Limits of all types
\n  - Rte_Cbk.h
\n  - COM call-back declarations
\n  - Rte_Cfg.h
\n  - User definitions affecting the behavior of generated RTE
\n  - Ex: Enable/ Disable VFB TRACE etc.
</string>
    <string name="_512_m16">Rte_Hook.h
\n  - Declarations of hook functions for Tracing
\n\nRte_Main.h
\n  - Declarations of Rte_St art and Rte_St op functions
\n\nRte.h
\n  - Fixed elements of RTE
\n\nRte.c
\n  - RTE service definitions
\n  - Definitions of OS tasks
\n  - Definition of COM call-backs
\n  - Definition of RAM variables for RTE
\n  - Rte_St art and Rte_St op definitions
\n  - Etc.
</string>
    <string name="_513_m1">Calibration
\n\nAdjust ECU SW to fit into specific vehicle needs
\n\nDifferent mechanisms are provided
\n\nMechanisms are
\n  - Measurement
\n  - Measure what’s going on in the ECU
\n  - Tools available to monitor the data
\n  - Calibr ation
\n  - Based on measurement data, data shall be modified
\n  - Modify and fine tune the data suitable for specific project needs</string>
    <string name="_513_m2">Offline and Online Calibration
\n\nMethods based on how the calibration data is changed
\n\nTypes
\n  - Offline
\n  - Calibration data re-flashed while ECU is offline
\n  - Online
\n  - Calibration data modified while at ECU is online
\n  - The calibration data is updated at runtime by external tester
\n  - The new data written in to ECU at shutdown t ime</string>
    <string name="_513_m3">Per-Instance Memory
\n\nA specific memory needed for a specific SW-C instance
\n\nStatically defined memory parts
\n\nRTE service Rte_Pim to access the specific memory part of that instance
\n\nMemory can be accessed by Runnables of that SW-C instance
\n\nThis memory is not sharable across other SW-Cs
</string>
    <string name="_513_m4">Calibration parameters
\n\nDesign Calibr ation parameters in AUTOSAR
\n  - Design as Calibr ation SW-Cs
\n  - Only have PPorts of type Cal-Pr m
\n  - Uses Cal-Pr m interface
\n  - Just provides the Cal-Pr m data to other SW-Cs
\n  - Can’t have runnables, events etc…No internal behavior
\n  - Accessthe Cal-Pr m data thru Rte_CalPr m service
</string>
    <string name="_513_m5">Internal Calibration parameters with in SW-Cs
\n\nDefined in SW-C description
\n\nCan be only used with in SW-C
\n\nTwo types
\n  - Per-Instance
\n  - Separate for each instance of SW-C
\n  - Shared
\n  - Shared across all instances of SW-C
\n\nRTE provides Rte_CDat a service to access the data</string>
    <string name="_513_m6">Calibration methods
\n\nTwo types of calibration
\n  - Offline calibration
\n  - No changes to calibration parameters at run t ime
\n  - All calibration parametersare read from ROM directly
\n  - Re-flashed in ROM directly
\n  - RTE just shares the info by reading from ROM
\n  - Online calibration
\n  - RTE allocates RAM to these calibration parameters
\n  - Changes to parameters at runtime thru external tools
\n  - The latest data written back to ECU at shutdown
\n  - The new data shall be read from next journey onwards</string>


    <string name="a1">
        The interoperability of solutions requires a high quality standard. AUTOSAR has defined a process to ensure such high quality when changes are introduced in a revision or when new features are introduced in new minor or major releases.
        \n\n
        AUTOSAR is also continuously monitoring the interoperability of AUTOSAR tool chain solutions and provide acceptance tests for the Classic Platform which enable an early assessment of suppliers’ basic software solutions in a development process.
        \n\n
        AUTOSAR’s Adaptive Platform is designed for interoperability with other software platforms. By using dynamic service oriented communication patterns, applications can easily exchange information with for example infotainment systems.
    </string>
    <string name="a2">
        New use-cases require the development of the Adaptive Platform.
        \n
        Highly automated driving where the driver temporarily and/or partially passes responsibility for driving to the vehicle. This requires for instance communication with traffic lights, the use of high-performance micro-controllers and computing.
        \n\n
        Car-2-X applications require interaction to vehicles and off-board systems. That means the system has to provide secure on-board communication, support of cross domain computing platforms, smartphone integration, integration of non-AUTOSAR systems, and so on.
        \n\n
        Cloud based services will require dedicated means for security such as secure cloud interaction and emergency vehicle preemption. They will enable remote and distributed services, for instance remote diagnostics, in-field flashing, repair and exchange handling.
    </string>
    <string name="a3">
        The Classic Platform is the first choice for deeply embedded ECUs with high demands regarding safety and deterministic execution. It targets small and medium sized microcontrollers.
        \n\n
        The Adaptive Platform supports adaptive deployment of applications and interaction with Classic Platform and non-AUTOSAR systems. It targets high performance microcontrollers.
    </string>
    <string name="a4">
        Updates and improvements of the standard will be introduced by future versions of AUTOSAR. Corrections are handled by a change management process and are provided as revisions of the existing releases. New features are matured in concepts which are introduced only in new releases. New minor releases accept only backward compatible features whereas major releases could introduce non backward compatible features. The AUTOSAR versions are numbered according to this scheme: andlt;major releaseandgt;.andlt;minor releaseandgt;.andlt;revisionandgt;.
        \n\n
        AUTOSAR’s standard Adaptive Platform makes use of agile development methods. That means functions and updates are developed in sprints. There is a regular release cycle to introduce those functions and updates into the market.
    </string>
    <string name="a5">
        Yes, AUTOSAR provides application interfaces for Body, Chassis, Pedestrian and Occupant Safety, and Powertrain applications.
    </string>
    <string name="a6">
        One of the main requirements of AUTOSAR is to assure the interoperability with legacy software. This will enable the re-use of existing, non-AUTOSAR compliant software, e.g. drivers. The most obvious way to reach this integration is using a Complex Driver as a wrapper around the non-AUTOSAR compliant software.
    </string>
    <string name="a7">
        The acceptance of AUTOSAR will depend heavily on processing and memory requirements. The modular architecture of AUTOSAR provides a scalable solution where users or implementers can discard modules or configure out features of the basic software in order to limit the memory and performance impacts in micro controllers.
    </string>
    <string name="a8">
        Using and implementing existing standards is given the highest priority.
        \n\n
        This has been the case since the beginning of the project. For example AUTOSAR’s operating system and communication stack were based on OSEK, and the AUTOSAR System Template was based on ASAM. Furthermore AUTOSAR introduces support for new standard when there is a market need for the automotive industry.
        \n\n
        As AUTOSAR members also participate to the elaboration of other standard, it has been possible to provide, with AUTOSAR, and standardized software solution to implement other standard as soon as they are published. For instance functional safety mechanisms were added to support ISO 26262, and the partial networking or Can FD concepts were introduced to support new versions of ISO 11898.
    </string>

</resources>
